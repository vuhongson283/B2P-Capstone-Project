// contexts/SignalRContext.js
import { createContext, useContext, useEffect, useState } from 'react';
import { HubConnectionBuilder, LogLevel } from '@microsoft/signalr';
import signalRService from '../services/signalRService'; // ‚úÖ ADD THIS
import dayjs from 'dayjs';

const SignalRContext = createContext();

export const SignalRProvider = ({ children, facilityIds = [] }) => {
    const [connection, setConnection] = useState(null);
    const [isConnected, setIsConnected] = useState(false);
    const [connectionStatus, setConnectionStatus] = useState('Disconnected');

    useEffect(() => {
        console.log('üöÄ SignalRProvider: Initializing connection...');

        const connectToSignalR = async () => {
            try {
                console.log('üîå Creating SignalR connection to: https://api.book2play.site/bookinghub');

                const newConnection = new HubConnectionBuilder()
                    .withUrl('https://api.book2play.site/bookinghub')
                    .configureLogging(LogLevel.Information)
                    .withAutomaticReconnect({
                        nextRetryDelayInMilliseconds: retryContext => {
                            console.log(`üîÑ Retry attempt ${retryContext.previousRetryCount + 1}`);
                            // Retry after 0, 2, 10, 30 seconds, then stop
                            if (retryContext.previousRetryCount < 4) {
                                return Math.pow(2, retryContext.previousRetryCount) * 1000;
                            } else {
                                return null; // Stop retrying
                            }
                        }
                    })
                    .build();

                // Connection event handlers
                newConnection.onreconnecting(error => {
                    console.log('üîÑ SignalR Reconnecting...', error);
                    setIsConnected(false);
                    setConnectionStatus('Reconnecting');
                });

                newConnection.onreconnected(connectionId => {
                    console.log('‚úÖ SignalR Reconnected with ID:', connectionId);
                    setIsConnected(true);
                    setConnectionStatus('Connected');
                });

                newConnection.onclose(error => {
                    console.log('‚ùå SignalR Connection Closed:', error);
                    setIsConnected(false);
                    setConnectionStatus('Disconnected');
                });

                // Start connection
                console.log('üîå Starting SignalR connection...');
                setConnectionStatus('Connecting');
                await newConnection.start();

                console.log('‚úÖ SignalR Connected successfully!');
                console.log('‚úÖ Connection ID:', newConnection.connectionId);
                console.log('‚úÖ Connection State:', newConnection.state);

                setConnection(newConnection);
                setIsConnected(true);
                setConnectionStatus('Connected');

                // Test the connection by listening to a general event
                // Replace the entire BookingStatusChanged handler with this:

                newConnection.on('BookingStatusChanged', async (data) => {
                    console.log('üéØ [SignalRProvider] RAW BookingStatusChanged received:', data);

                    try {
                        const bookingId = data.bookingId || data.BookingId;
                        const courtName = data.courtName || data.CourtName;
                        const CusName = data.customerName || data.CustomerName;



                        console.log('üîç [DEBUG] Processing SignalR data directly:', data);
                        console.log('üîç [DEBUG] Data keys:', Object.keys(data));
                        console.log('üîç [DEBUG] Status-related fields:', {
                            status: data.status,
                            newStatus: data.newStatus,
                            statusId: data.statusId,
                            newStatusId: data.newStatusId,
                            action: data.action
                        });

                        // ‚úÖ FETCH FULL BOOKING DETAILS FROM API
                        let bookingDetails = null;
                        try {
                            console.log('üîç [DEBUG] Starting API fetch for bookingId:', bookingId);
                            const token = localStorage.getItem('token');
                            console.log('üîç [DEBUG] Token exists:', !!token);
                            console.log('üîç [DEBUG] Token preview:', token ? token.substring(0, 20) + '...' : 'null');

                            const apiUrl = `https://api.book2play.site/api/booking/${bookingId}`;
                            console.log('üîç [DEBUG] API URL:', apiUrl);

                            console.log('üîç [DEBUG] Making fetch request...');
                            const response = await fetch(apiUrl, {
                                headers: {
                                    'Authorization': `Bearer ${token}`,
                                    'Content-Type': 'application/json'
                                }
                            });

                            console.log('üîç [DEBUG] Response status:', response.status);
                            console.log('üîç [DEBUG] Response ok:', response.ok);

                            if (response.ok) {
                                const bookingDetailsRaw = await response.json();
                                const bookingDetails = bookingDetailsRaw.data || {};
                                const slot = Array.isArray(bookingDetails.slots) && bookingDetails.slots.length > 0 ? bookingDetails.slots[0] : {};

                                // L·∫•y t√™n kh√°ch h√†ng n·∫øu c√≥
                                const customerName = bookingDetails.customerName || bookingDetails.fullName || bookingDetails.email || 'Kh√°ch h√†ng';

                                // T·∫°o notification v·ªõi th√¥ng tin ƒë√∫ng
                                const paymentNotification = {
                                    bookingId: bookingId,
                                    facilityId: bookingDetails.facilityId || slot.facilityId || data.facilityId || data.FacilityId,
                                    courtName: slot.courtName || `Booking #${bookingId}`,
                                    customerName: customerName,
                                    date: bookingDetails.checkInDate
                                        ? dayjs(bookingDetails.checkInDate).format('DD/MM/YYYY')
                                        : (data.date || data.Date || dayjs().format('DD/MM/YYYY')),
                                    timeSlot: slot.startTime && slot.endTime
                                        ? `${slot.startTime} - ${slot.endTime}`
                                        : (data.timeSlot || data.TimeSlot || 'Unknown time'),
                                    checkInDate: bookingDetails.checkInDate,
                                    checkInTime: slot.startTime,
                                    checkOutTime: slot.endTime,
                                    totalAmount: bookingDetails.totalPrice || data.totalAmount || data.TotalAmount || 0,
                                    status: 'paid',
                                    statusId: 7,
                                    action: 'paid'
                                };

                                console.log('üéØ [DEBUG] Payment notification with API data:', paymentNotification);

                                // ‚úÖ DEBOUNCE FOR PAYMENT
                                const paymentEventKey = `payment-${bookingId}`;

                                if (window.lastPaymentEvents && window.lastPaymentEvents[paymentEventKey]) {
                                    const timeSinceLastEvent = Date.now() - window.lastPaymentEvents[paymentEventKey];
                                    if (timeSinceLastEvent < 3000) {
                                        console.log('‚è≠Ô∏è Ignoring duplicate payment event within 3 seconds');
                                        return;
                                    }
                                }

                                if (!window.lastPaymentEvents) window.lastPaymentEvents = {};
                                window.lastPaymentEvents[paymentEventKey] = Date.now();

                                setTimeout(() => {
                                    if (window.lastPaymentEvents && window.lastPaymentEvents[paymentEventKey]) {
                                        delete window.lastPaymentEvents[paymentEventKey];
                                    }
                                }, 10000);

                                // Khi ƒë√£ t·∫°o paymentNotification:
                                // (ƒê·∫∑t ƒëo·∫°n n√†y ngay tr∆∞·ªõc khi g·ªçi handler)
                                if (
                                    Array.isArray(facilityIds) &&
                                    paymentNotification.courtId && // ho·∫∑c paymentNotification.facilityId n·∫øu c√≥
                                    !facilityIds.includes(paymentNotification.courtId)
                                ) {
                                    console.log(`‚è≠Ô∏è [SignalR] Payment notification for courtId ${paymentNotification.courtId} not owned by this court owner, skipping.`);
                                    return;
                                }

                                // Trigger payment notification
                                if (signalRService.eventHandlers.onBookingPaid) {
                                    signalRService.eventHandlers.onBookingPaid(paymentNotification);
                                }

                            } else {
                                const errorText = await response.text();
                                console.log('‚ùå [DEBUG] Failed to fetch booking details');
                                console.log('‚ùå [DEBUG] Status:', response.status);
                                console.log('‚ùå [DEBUG] Status text:', response.statusText);
                                console.log('‚ùå [DEBUG] Error response:', errorText);
                            }
                        } catch (fetchError) {
                            console.error('‚ùå [DEBUG] Fetch error occurred:', fetchError);
                            console.error('‚ùå [DEBUG] Error message:', fetchError.message);
                            console.error('‚ùå [DEBUG] Error stack:', fetchError.stack);
                        }

                        // ‚úÖ CHECK IF THIS IS A CANCELLATION FIRST
                        const isCancellation =
                            data.status === 'cancelled' ||
                            data.newStatus === 'cancelled' ||
                            data.status === 'Cancelled' ||
                            data.newStatus === 'Cancelled' ||
                            data.statusId === 9 ||
                            data.newStatusId === 9 ||
                            data.action === 'cancelled' ||
                            data.action === 'cancel';

                        if (isCancellation) {
                            console.log('üö® [SignalRProvider] CANCELLATION detected:', data);

                            const cancellationNotification = {
                                bookingId: bookingId,
                                courtName: bookingDetails?.courtName || data.courtName || data.CourtName || `Booking #${bookingId}`,
                                customerName: bookingDetails?.customerName || data.customerName || data.CustomerName || 'Kh√°ch h√†ng',
                                date: bookingDetails?.checkInDate ? dayjs(bookingDetails.checkInDate).format('DD/MM/YYYY') :
                                    (data.date || data.Date || dayjs().format('DD/MM/YYYY')),
                                timeSlot: bookingDetails?.timeSlot ||
                                    (bookingDetails?.checkInTime && bookingDetails?.checkOutTime
                                        ? `${bookingDetails.checkInTime} - ${bookingDetails.checkOutTime}`
                                        : (data.timeSlot || data.TimeSlot || 'Unknown time')),
                                totalAmount: bookingDetails?.totalAmount || data.totalAmount || data.TotalAmount || 0,
                                status: 'cancelled',
                                statusId: 9,
                                action: 'cancelled',
                                reason: data.reason || data.Reason || 'H·ªßy ƒë∆°n'
                            };

                            console.log('üéØ [DEBUG] Cancellation notification:', cancellationNotification);

                            // ‚úÖ DEBOUNCE FOR CANCELLATION
                            const eventKey = `cancel-${bookingId}`;

                            if (window.lastCancelEvents && window.lastCancelEvents[eventKey]) {
                                const timeSinceLastEvent = Date.now() - window.lastCancelEvents[eventKey];
                                if (timeSinceLastEvent < 3000) {
                                    console.log('‚è≠Ô∏è Ignoring duplicate cancellation event within 3 seconds');
                                    return;
                                }
                            }

                            if (!window.lastCancelEvents) window.lastCancelEvents = {};
                            window.lastCancelEvents[eventKey] = Date.now();

                            setTimeout(() => {
                                if (window.lastCancelEvents && window.lastCancelEvents[eventKey]) {
                                    delete window.lastCancelEvents[eventKey];
                                }
                            }, 10000);

                            // Trigger cancellation notification
                            if (signalRService.eventHandlers.onBookingCancelled) {
                                signalRService.eventHandlers.onBookingCancelled(cancellationNotification);
                            }

                            return; // Don't process as payment
                        }

                        // ‚úÖ OTHERWISE, PROCESS AS PAYMENT (using API data when available)
                        console.log('üí∞ [SignalRProvider] Processing as PAYMENT:', data);

                        const paymentNotification = {
                            bookingId: bookingId,
                            courtName: courtName,
                            customerName: CusName,
                            date: bookingDetails?.checkInDate ? dayjs(bookingDetails.checkInDate).format('DD/MM/YYYY') :
                                (data.date || data.Date || dayjs().format('DD/MM/YYYY')),
                            timeSlot: bookingDetails?.timeSlot ||
                                (bookingDetails?.checkInTime && bookingDetails?.checkOutTime
                                    ? `${bookingDetails.checkInTime} - ${bookingDetails.checkOutTime}`
                                    : (data.timeSlot || data.TimeSlot || 'Unknown time')),
                            checkInDate: bookingDetails?.checkInDate,
                            checkInTime: bookingDetails?.checkInTime,
                            checkOutTime: bookingDetails?.checkOutTime,
                            totalAmount: bookingDetails?.totalAmount || data.totalAmount || data.TotalAmount || 0,
                            status: 'paid',
                            statusId: 7,
                            action: 'paid'
                        };

                        console.log('üéØ [DEBUG] Payment notification with API data:', paymentNotification);

                        // ‚úÖ DEBOUNCE FOR PAYMENT
                        const paymentEventKey = `payment-${bookingId}`;

                        if (window.lastPaymentEvents && window.lastPaymentEvents[paymentEventKey]) {
                            const timeSinceLastEvent = Date.now() - window.lastPaymentEvents[paymentEventKey];
                            if (timeSinceLastEvent < 3000) {
                                console.log('‚è≠Ô∏è Ignoring duplicate payment event within 3 seconds');
                                return;
                            }
                        }

                        if (!window.lastPaymentEvents) window.lastPaymentEvents = {};
                        window.lastPaymentEvents[paymentEventKey] = Date.now();

                        setTimeout(() => {
                            if (window.lastPaymentEvents && window.lastPaymentEvents[paymentEventKey]) {
                                delete window.lastPaymentEvents[paymentEventKey];
                            }
                        }, 10000);

                        // Khi ƒë√£ t·∫°o paymentNotification:
                        // (ƒê·∫∑t ƒëo·∫°n n√†y ngay tr∆∞·ªõc khi g·ªçi handler)
                        if (
                            Array.isArray(facilityIds) &&
                            paymentNotification.facilityId &&
                            !facilityIds.includes(paymentNotification.facilityId)
                        ) {
                            console.log(`‚è≠Ô∏è [SignalR] Payment notification for facilityId ${paymentNotification.facilityId} not owned by this court owner, skipping.`);
                            return;
                        }

                        // Trigger payment notification
                        if (signalRService.eventHandlers.onBookingPaid) {
                            signalRService.eventHandlers.onBookingPaid(paymentNotification);
                        }

                    } catch (error) {
                        console.error('‚ùå Error handling BookingStatusChanged:', error);
                        console.error('‚ùå Error message:', error.message);
                        console.error('‚ùå Error stack:', error.stack);

                        // ‚úÖ FALLBACK: Still trigger notification with basic info
                        const bookingId = data.bookingId || data.BookingId;
                        const fallbackNotification = {
                            bookingId: bookingId,
                            courtName: `Booking #${bookingId}`,
                            customerName: 'Kh√°ch h√†ng',
                            date: dayjs().format('DD/MM/YYYY'),
                            timeSlot: 'Unknown time',
                            totalAmount: 0,
                            status: 'paid',
                            statusId: 7,
                            action: 'paid'
                        };

                        // Still trigger notification even if processing fails
                        if (signalRService.eventHandlers.onBookingPaid) {
                            signalRService.eventHandlers.onBookingPaid(fallbackNotification);
                        }
                    }
                });
            } catch (error) {
                console.error('‚ùå SignalR Connection Error:', error);
                console.error('‚ùå Error details:', error.message);
                console.error('‚ùå Error stack:', error.stack);
                setConnectionStatus('Failed');

                // Fallback to HTTP if HTTPS fails
                if (error.message.includes('SSL') || error.message.includes('certificate') ||
                    error.message.includes('HTTPS') || error.message.includes('ERR_CERT')) {
                    console.log('üí° HTTPS failed, trying HTTP fallback...');
                    tryHttpConnection();
                } else {
                    console.log('üí° Trying HTTP fallback anyway...');
                    tryHttpConnection();
                }
            }
        };

        const tryHttpConnection = async () => {
            try {
                console.log('üîå Trying HTTP connection to: http://api.book2play.site/bookinghub');

                const httpConnection = new HubConnectionBuilder()
                    .withUrl('http://api.book2play.site/bookinghub')
                    .configureLogging(LogLevel.Information)
                    .withAutomaticReconnect()
                    .build();

                await httpConnection.start();
                console.log('‚úÖ SignalR Connected via HTTP');
                console.log('‚úÖ HTTP Connection ID:', httpConnection.connectionId);

                setConnection(httpConnection);
                setIsConnected(true);
                setConnectionStatus('Connected');

                // Test the HTTP connection
                httpConnection.on('BookingStatusChanged', (data) => {
                    console.log('üéØ [SignalRProvider HTTP] RAW BookingStatusChanged received:', data);
                });

            } catch (httpError) {
                console.error('‚ùå HTTP connection also failed:', httpError);
                console.error('‚ùå HTTP Error details:', httpError.message);
                setConnectionStatus('Failed');
            }
        };

        connectToSignalR();

        // Cleanup
        return () => {
            if (connection) {
                console.log('üîå [SignalRProvider] Cleaning up SignalR connection...');
                connection.stop();
            }
        };
    }, [facilityIds]); // Remove connection dependency to avoid infinite loop

    // Helper method to subscribe to events with cleanup
    const useSignalREvent = (eventName, handler, dependencies = []) => {
        useEffect(() => {
            if (!connection || !isConnected) {
                console.log(`‚ùå Cannot subscribe to ${eventName}: no connection or not connected`);
                return;
            }

            console.log(`üì° [useSignalREvent] Subscribing to event: ${eventName}`);
            console.log(`üì° [useSignalREvent] Connection state: ${connection.state}`);
            console.log(`üì° [useSignalREvent] Is connected: ${isConnected}`);

            connection.on(eventName, handler);

            return () => {
                console.log(`üì° [useSignalREvent] Unsubscribing from event: ${eventName}`);
                if (connection) {
                    connection.off(eventName, handler);
                }
            };
        }, [connection, isConnected, eventName, ...dependencies]);
    };

    const contextValue = {
        connection,
        isConnected,
        connectionStatus,
        useSignalREvent // Helper for components
    };

    console.log('üîç [SignalRProvider] Current state:', {
        hasConnection: !!connection,
        isConnected,
        connectionStatus,
        connectionId: connection?.connectionId,
        connectionState: connection?.state
    });

    return (
        <SignalRContext.Provider value={contextValue}>
            {children}
        </SignalRContext.Provider>
    );
};

// Custom hook to use SignalR
export const useSignalR = () => {
    const context = useContext(SignalRContext);
    if (!context) {
        throw new Error('useSignalR must be used within SignalRProvider');
    }

    console.log('üéØ [useSignalR] Hook called with context:', {
        hasConnection: !!context.connection,
        isConnected: context.isConnected,
        connectionStatus: context.connectionStatus
    });

    return context;
};

// Custom hook for booking-specific events
export const useBookingSignalR = (bookingId) => {
    console.log('üéØ [useBookingSignalR] Hook called with bookingId:', bookingId);

    const { connection, isConnected, useSignalREvent, connectionStatus } = useSignalR();
    const [bookingUpdates, setBookingUpdates] = useState(null);

    console.log('üéØ [useBookingSignalR] Current state:', {
        bookingId,
        hasConnection: !!connection,
        isConnected,
        connectionStatus
    });

    // Listen for booking status changes
    useSignalREvent(
        'BookingStatusChanged',
        (data) => {
            console.log('üì® [useBookingSignalR] Received BookingStatusChanged:', data);
            console.log('üì® [useBookingSignalR] Current bookingId:', bookingId);
            console.log('üì® [useBookingSignalR] Received BookingId:', data.BookingId);
            console.log('üì® [useBookingSignalR] BookingId type check:', typeof data.BookingId, typeof bookingId);

            // Only update if it's for the current booking
            if (data.BookingId && bookingId && data.BookingId.toString() === bookingId.toString()) {
                console.log(`‚úÖ [useBookingSignalR] Booking ${bookingId} status updated:`, data);
                setBookingUpdates(data);
            } else {
                console.log(`‚ùå [useBookingSignalR] BookingId mismatch or missing data:`, {
                    dataBookingId: data.BookingId,
                    currentBookingId: bookingId,
                    match: data.BookingId && bookingId && data.BookingId.toString() === bookingId.toString()
                });
            }
        },
        [bookingId]
    );

    return {
        connection,
        isConnected,
        connectionStatus,
        bookingUpdates,
        clearUpdates: () => setBookingUpdates(null)
    };
};